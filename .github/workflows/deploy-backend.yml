# ========================================
# GitHub Actions - Backend Deployment
# Auto-deploy to VPS on push to main
# ========================================

name: Deploy Backend to VPS

on:
  push:
    branches:
      - main
    paths:
      - 'server/**'
      - '.github/workflows/deploy-backend.yml'
  workflow_dispatch:

env:
  DEPLOY_PATH: '/home/travel_project'

jobs:
  deploy:
    name: Deploy to VPS
    runs-on: ubuntu-latest
    
    steps:
      # ============= Checkout Code =============
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # ============= Setup SSH Key =============
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          printf "%s\n" "${{ secrets.VPS_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts

      # ============= Test SSH Connection =============
      - name: Test SSH connection
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} \
            "echo 'SSH connection successful'"

      # ============= Deploy Application =============
      - name: Deploy to VPS
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'ENDSSH'
          
          set -e
          
          echo "========================================"
          echo "Starting Deployment - $(date)"
          echo "========================================"
          
          # Navigate to deployment directory
          cd ${{ env.DEPLOY_PATH }}
          
          # Pull latest code
          echo "Pulling latest code from GitHub..."
          git fetch origin main
          git reset --hard origin/main
          
          # Navigate to server directory
          cd server
          
          # Verify .env exists
          if [ ! -f .env ]; then
            echo "ERROR: .env file not found! Please configure manually first."
            exit 1
          fi
          
          # Fix Windows line endings (CRLF -> LF) before sourcing
          sed -i 's/\r$//' .env
          
          # Load environment variables (export for subshells)
          set -a
          source .env
          set +a
          
          echo "========================================"
          echo "Step 1: Backup Current Database"
          echo "========================================"
          
          # Create backup directory
          mkdir -p backups
          BACKUP_FILE="backups/backup_$(date +%Y%m%d_%H%M%S).sql"
          
          # Check if postgres container is running
          if docker compose ps postgres 2>/dev/null | grep -q "running"; then
            echo "Backing up current database..."
            docker compose exec -T postgres pg_dump \
              -U "${POSTGRES_USERNAME:-postgres}" \
              -d "${POSTGRES_DBNAME:-railway}" \
              -Fc --no-owner --no-privileges \
              > "$BACKUP_FILE" 2>/dev/null || true
            
            if [ -s "$BACKUP_FILE" ]; then
              echo "✅ Database backup saved to: $BACKUP_FILE"
              # Keep only last 5 backups
              ls -t backups/backup_*.sql 2>/dev/null | tail -n +6 | xargs rm -f 2>/dev/null || true
            else
              echo "⚠️ No data to backup (new deployment or empty database)"
              rm -f "$BACKUP_FILE"
            fi
          else
            echo "⚠️ Postgres not running, skipping backup"
          fi
          
          echo "========================================"
          echo "Step 2: Start Database First"
          echo "========================================"
          
          # Stop all services except database
          echo "Stopping application services..."
          docker compose stop flask-app celery-worker celery-beat nginx 2>/dev/null || true
          
          # Start only database services first
          echo "Starting database services..."
          docker compose up -d postgres redis
          
          # Wait for postgres to be ready
          echo "Waiting for PostgreSQL to be ready..."
          for i in {1..30}; do
            if docker compose exec -T postgres pg_isready -U "${POSTGRES_USERNAME:-postgres}" >/dev/null 2>&1; then
              echo "✅ PostgreSQL is ready!"
              break
            fi
            echo "Waiting for PostgreSQL... ($i/30)"
            sleep 2
          done
          
          # Check if database exists, if not create it
          echo "Checking database..."
          DB_EXISTS=$(docker compose exec -T postgres psql -U "${POSTGRES_USERNAME:-postgres}" -lqt | cut -d \| -f 1 | grep -w "${POSTGRES_DBNAME:-railway}" || true)
          
          if [ -z "$DB_EXISTS" ]; then
            echo "Creating database ${POSTGRES_DBNAME:-railway}..."
            docker compose exec -T postgres psql -U "${POSTGRES_USERNAME:-postgres}" -c "CREATE DATABASE ${POSTGRES_DBNAME:-railway};" 2>/dev/null || true
          fi
          
          # Restore from backup if database is empty and backup exists
          TABLE_COUNT=$(docker compose exec -T postgres psql -U "${POSTGRES_USERNAME:-postgres}" -d "${POSTGRES_DBNAME:-railway}" -tAc "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public';" 2>/dev/null || echo "0")
          
          if [ "$TABLE_COUNT" = "0" ] || [ -z "$TABLE_COUNT" ]; then
            LATEST_BACKUP=$(ls -t backups/backup_*.sql 2>/dev/null | head -1)
            if [ -n "$LATEST_BACKUP" ] && [ -s "$LATEST_BACKUP" ]; then
              echo "Database is empty, restoring from: $LATEST_BACKUP"
              docker compose exec -T postgres pg_restore \
                -U "${POSTGRES_USERNAME:-postgres}" \
                -d "${POSTGRES_DBNAME:-railway}" \
                --no-owner --no-privileges \
                < "$LATEST_BACKUP" 2>/dev/null || true
              echo "✅ Database restored!"
            else
              echo "⚠️ No backup found, starting with fresh database"
            fi
          else
            echo "✅ Database has $TABLE_COUNT tables, skipping restore"
          fi
          
          echo "========================================"
          echo "Step 3: Build and Start Application"
          echo "========================================"
          
          # Build and start all services
          echo "Building and starting all services..."
          if ! docker compose up -d --build --force-recreate; then
            echo "❌ FATAL: docker compose up failed!"
            docker compose ps
            docker compose logs --tail=50
            exit 1
          fi
          
          # Prune old images to save disk space
          echo "Cleaning up old images..."
          docker image prune -f
          
          # Wait for services to be healthy
          echo "Waiting for services to start..."
          sleep 20
          
          # Verify ALL critical services are running
          echo ""
          echo "Verifying critical services..."
          REQUIRED_SERVICES=("postgres" "redis" "flask-app" "nginx")
          MISSING_SERVICES=()
          
          for service in "${REQUIRED_SERVICES[@]}"; do
            if ! docker compose ps "$service" --format json 2>/dev/null | grep -q "running\|healthy"; then
              echo "❌ Service '$service' is NOT running!"
              MISSING_SERVICES+=("$service")
            else
              echo "✅ Service '$service' is running"
            fi
          done
          
          if [ ${#MISSING_SERVICES[@]} -gt 0 ]; then
            echo ""
            echo "❌ FATAL: Missing critical services: ${MISSING_SERVICES[*]}"
            echo ""
            echo "Container status:"
            docker compose ps
            echo ""
            echo "Logs from failed services:"
            for service in "${MISSING_SERVICES[@]}"; do
              echo "======== $service logs ========"
              docker compose logs --tail=50 "$service" 2>&1 || echo "No logs available"
            done
            exit 1
          fi
          
          # Show running containers
          echo ""
          echo "All running containers:"
          docker compose ps
          
          # Check Flask logs for errors
          echo ""
          echo "Recent Flask logs:"
          docker compose logs --tail=30 flask-app
          
          # Check Nginx logs
          echo ""
          echo "Recent Nginx logs:"
          docker compose logs --tail=20 nginx
          
          echo ""
          echo "========================================"
          echo "✅ All services started successfully!"
          echo "========================================"
          ENDSSH

      # ============= Health Check =============
      - name: Verify deployment
        run: |
          echo "Verifying deployment health..."
          
          # Wait for services to stabilize
          sleep 15
          
          # Check health endpoint via HTTPS
          HEALTH_URL="https://api.phamphong.id.vn/health"
          
          echo "Testing: $HEALTH_URL"
          
          for i in {1..15}; do
            echo "Health check attempt $i/15..."
            
            # Use verbose curl to see what's happening
            HTTP_CODE=$(curl -s -o /tmp/health_response.txt -w "%{http_code}" --connect-timeout 10 --max-time 30 "$HEALTH_URL" 2>/dev/null || echo "000")
            RESPONSE=$(cat /tmp/health_response.txt 2>/dev/null || echo "")
            
            echo "  HTTP Code: $HTTP_CODE"
            echo "  Response: $RESPONSE"
            
            if [ "$HTTP_CODE" = "200" ] && echo "$RESPONSE" | grep -q "ok"; then
              echo "✅ Health check passed!"
              exit 0
            fi
            
            # If we get a response but not "ok", show details
            if [ "$HTTP_CODE" != "000" ] && [ "$HTTP_CODE" != "200" ]; then
              echo "  Got HTTP $HTTP_CODE - server is responding but not healthy yet"
            fi
            
            if [ "$HTTP_CODE" = "000" ]; then
              echo "  Connection failed - server may still be starting"
            fi
            
            sleep 10
          done
          
          echo ""
          echo "❌ Health check failed after 15 attempts"
          echo "Last HTTP Code: $HTTP_CODE"
          echo "Last Response: $RESPONSE"
          
          # Try to get more info via SSH
          echo ""
          echo "Checking container status on VPS..."
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} \
            "cd /home/travel_project/server && docker compose ps && echo '--- Flask Logs ---' && docker compose logs --tail=30 flask-app"
          
          exit 1

      # ============= Rollback on Failure =============
      - name: Rollback on failure
        if: failure()
        run: |
          echo "Deployment failed, attempting rollback..."
          
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'ENDSSH'
          
          cd ${{ env.DEPLOY_PATH }}
          
          # Get previous commit
          git reset --hard HEAD~1
          
          # Rebuild and restart
          cd server
          docker compose down
          docker compose up -d --build
          
          echo "Rolled back to previous version"
          ENDSSH

      # ============= Cleanup =============
      - name: Cleanup SSH key
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key
          echo "Cleaned up SSH key"

      # ============= Notify on Success =============
      - name: Send success notification
        if: success()
        run: |
          echo "Deployment successful!"
          echo "API URL: http://${{ secrets.VPS_HOST }}"
          echo "Health: http://${{ secrets.VPS_HOST }}/health"

      # ============= Notify on Failure =============
      - name: Send failure notification
        if: failure()
        run: |
          echo "Deployment failed!"
          echo "Check the logs above for details"
