# ========================================
# GitHub Actions - Backend Deployment
# Auto-deploy to VPS on push to main
# ========================================

name: Deploy Backend to VPS

on:
  push:
    branches:
      - main
    paths:
      - 'server/**'
      - '.github/workflows/deploy-backend.yml'
  workflow_dispatch:
    inputs:
      no_cache:
        description: 'Force rebuild without cache (use when dependencies change unexpectedly)'
        type: boolean
        default: false

env:
  DEPLOY_PATH: '/home/travel_project'

jobs:
  deploy:
    name: Deploy to VPS
    runs-on: ubuntu-latest
    
    steps:
      # ============= Checkout Code =============
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # ============= Setup SSH Key =============
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          printf "%s\n" "${{ secrets.VPS_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts

      # ============= Test SSH Connection =============
      - name: Test SSH connection
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} \
            "echo 'SSH connection successful'"

      # ============= Deploy Application =============
      - name: Deploy to VPS
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'ENDSSH'
          
          set -e
          
          echo "========================================"
          echo "Starting Deployment - $(date)"
          echo "========================================"
          
          cd ${{ env.DEPLOY_PATH }}
          
          echo "üì¶ Pulling latest code..."
          git fetch origin main
          git reset --hard origin/main
          
          cd server
          
          if [ ! -f .env ]; then
            echo "‚ùå .env file not found!"
            exit 1
          fi
          
          sed -i 's/\r$//' .env
          set -a; source .env; set +a
          
          echo "üíæ Backing up database..."
          mkdir -p backups
          BACKUP_FILE="backups/backup_$(date +%Y%m%d_%H%M%S).sql"
          
          if docker compose ps postgres 2>/dev/null | grep -q "running"; then
            docker compose exec -T postgres pg_dump \
              -U "${POSTGRES_USERNAME:-postgres}" \
              -d "${POSTGRES_DBNAME:-railway}" \
              -Fc --no-owner --no-privileges \
              > "$BACKUP_FILE" 2>/dev/null || true
            
            if [ -s "$BACKUP_FILE" ]; then
              echo "‚úÖ Backup saved"
              ls -t backups/backup_*.sql 2>/dev/null | tail -n +6 | xargs rm -f 2>/dev/null || true
            fi
          fi
          
          echo "üßπ Stopping containers..."
          docker compose down 2>/dev/null || true
          # NOTE: Removed 'docker builder prune -af' to preserve build cache for faster deploys
          # Only clean up dangling images (not build cache)
          docker image prune -f 2>/dev/null || true
          
          echo "üöÄ Building and deploying..."
          # Use cache for faster builds (only rebuild changed layers)
          # Add --no-cache if manually triggered with force rebuild option
          BUILD_ARGS=""
          if [ "${{ github.event.inputs.no_cache }}" == "true" ]; then
            echo "‚ö†Ô∏è Force rebuild enabled - ignoring cache"
            BUILD_ARGS="--no-cache"
          fi
          docker compose build $BUILD_ARGS
          docker compose up -d --force-recreate
          
          echo "‚è≥ Waiting for services to become healthy (max 5 minutes)..."
          TIMEOUT=300
          ELAPSED=0
          INTERVAL=10
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            # Check if flask-app is healthy
            if docker compose ps flask-app | grep -q "(healthy)"; then
              echo "‚úÖ Flask container is healthy after ${ELAPSED}s"
              break
            fi
            
            FLASK_STATUS=$(docker compose ps flask-app | tail -n 1 || echo "unknown")
            echo "‚è±Ô∏è  Waiting... (${ELAPSED}s/${TIMEOUT}s) - Status: ${FLASK_STATUS}"
            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "‚ö†Ô∏è  Health check timeout reached after ${TIMEOUT}s"
            echo "üìä Current status:"
            docker compose ps
            echo "üìã Flask logs:"
            docker compose logs --tail=50 flask-app
            exit 1
          fi
          
          docker image prune -f
          
          echo "üìä Final status:"
          docker compose ps
          
          echo "‚úÖ Deployment complete!"
          ENDSSH

      # ============= Show Logs =============
      - name: Show service logs
        if: success()
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'ENDSSH'
          cd /home/travel_project/server
          
          echo "Flask:"
          docker compose logs --tail=10 flask-app 2>&1 | tail -5
          
          echo "Nginx:"
          docker compose logs --tail=10 nginx 2>&1 | tail -5
          ENDSSH

      # ============= Cleanup =============
      - name: Cleanup SSH key
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key

      # ============= Notify =============
      - name: Notify
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ Deployment successful"
          else
            echo "‚ùå Deployment failed"
          fi
          echo "Check the logs above for details"

